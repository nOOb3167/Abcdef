%h{
#include <src/error.h>
#include <lua.h>
%}

class Tf:Act from G:Object
{
  public GQueue *qu;
  public lua_State *L;          /* The lua_State Act was created in */
  public lua_State *cr;

  /**
   * [-0, +1]
   * Push value of Registry key "ActCr".
   */
  public void actcr_get (self)
  {
    lua_State *thr;

    {
      lua_pushvalue (self->L, LUA_REGISTRYINDEX);
      lua_pushstring (self->L, "ActCr");
      lua_rawget (self->L, -2);

      thr = lua_tothread (self->L, -1);

      lua_pop (self->L, 1);
      lua_pop (self->L, 1);
    }

    //lua_pushthread (
  }

  public void actcr_ensure (self)
  {
    lua_pushvalue (self->L, LUA_REGISTRYINDEX);
    lua_pushstring (self->L, "ActCr");
    lua_rawget (self->L, -2);

    if (lua_isnil (self->L, -1))
      {
        lua_pushvalue (self->L, LUA_REGISTRYINDEX);
        lua_pushstring (self->L, "ActCr");
        lua_newtable (self->L);
        lua_rawset (self->L, -2);

        lua_pop (self-L, 1);
      }

    lua_pop (self->L, 1);
  }
  
  public void gcref_thread (self, lua_State *thread)
  {
    /**
     * Plan:
     * Ensure Registry key "ActCr" exists, and is a table.
     * Push said table on stack.
     * Push thread on stack.
     * Use luaL_ref.
     */
    int ref;

    self_ensure_actcr (self);

    {
      lua_pushvalue (self->L, LUA_REGISTRYINDEX);
      lua_pushthread (self->L, thread);
      ref = luaL_ref (self->L, -2);
      lua_pop (self->L, 1);
    }

    g_xassert (LUA_REFNIL != ref);

    {    
      lua_pushvalue (self->L, LUA_REGISTRYINDEX);
      lua_push
    }
  }

  public void init_d (self, lua_State *L)
  {
    /**
     * From the Lua manual:
     * There is no explicit function to close or to destroy a thread.
     * Threads are subject to garbage collection, like any Lua object. 
     *
     * First it's like: "Yay, GC is great!"
     * But then how does it track references/use?
     * I believe I definitely need to keep a reference somewhere tracked
     * by lua, the stack (No) or some Table. (In C Registry?).
     * (Some subtable in the C Registry, use luaL_ref)
     */
    lua_State *thr;
    thr = lua_newthread (L);
    g_xassert (thr);

    lua_pop (L, 1);

    self->qu = g_queue_new ();
    self->L = L;
    self->cr = thr;

    self_gcref_thread (self, thr);
  }

  public GObject *new (lua_State *L)
  {
    Self *self = GET_NEW;
    
    self_init_d (self, L);

    return G_OBJECT (self);
  }

}
